<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://faizilham.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://faizilham.github.io/" rel="alternate" type="text/html" /><updated>2025-05-16T14:35:09+00:00</updated><id>https://faizilham.github.io/feed.xml</id><title type="html">faiz.memdump()</title><subtitle>A digital snapshot of my memories
</subtitle><author><name>Faiz Ilham</name></author><entry><title type="html">Making a budget Pascal compiler to WebAssembly</title><link href="https://faizilham.github.io/making-budget-pascal-compiler" rel="alternate" type="text/html" title="Making a budget Pascal compiler to WebAssembly" /><published>2021-12-21T00:00:00+00:00</published><updated>2021-12-21T00:00:00+00:00</updated><id>https://faizilham.github.io/making-budget-pascal-compiler</id><content type="html" xml:base="https://faizilham.github.io/making-budget-pascal-compiler"><![CDATA[<p><em>TL;DR: I made a budget Pascal compiler to WebAssembly so that I can play a hangman game that my friends and I made 10 years ago. Check out the <a href="https://faizilham.github.io/lab/budget-pascal/#hangman">demo</a> and the <a href="https://github.com/faizilham/budgetpascal">github repository</a>.</em></p>

<p>About a month ago, I was reorganizing my old files in my laptop when I found something interesting. It was a console-based hangman game that my friends and I made in Pascal as a final project for intro to programming class<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> back in 2011. I had just finished reading <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> by Robert Nystrom, so I thought it would be fun to move to compilers and try to compile the hangman game to WebAssembly. Here are some of many interesting things I learned and made during the development.</p>

<h3 id="choosing-and-budgeting-the-features">Choosing and “budgeting” the features</h3>
<p>Making a full-fledge Pascal compiler is a very time-consuming task. I want the project to be small enough that I can finish it in 4-6 weeks, so I decided to support only a subset of Pascal features and language constructs (hence, “budget”). I chose which features to implement based on three principles:</p>
<ol>
  <li>The compiler should be able to compile the hangman game without any changes to the game’s source code. This means I need to handle things that normally I don’t handle like files, output formatting, standard library methods like <code class="language-plaintext highlighter-rouge">pos</code>, <code class="language-plaintext highlighter-rouge">clrscr</code>, <code class="language-plaintext highlighter-rouge">readkey</code>, and so on.</li>
  <li>The compiler should be able to handle things that “naturally” exist given the chosen features. For example, while the game source code doesn’t have any recursion call or use any floating-point number type, I think it would be weird not implementing those. However, things like dynamic length array, dynamic memory allocation, pointers, and fully-implemented set type are surplus to the requirements. This rationale is quite arbitrary but I settled on it.</li>
  <li>The compiler should compile a strict subset of Pascal. This means while it can’t compile some Pascal programs, all programs that it can compile should be compilable by other full-feature Pascal compiler like FreePascal. There should be no program that is valid for this compiler but invalid for other compilers. This is easier said than done and I’m still not 100% sure if the implementation is indeed a strict subset.</li>
</ol>

<p>The full detail of chosen features can be found in the <a href="https://github.com/faizilham/budgetpascal#which-subset-of-pascal">repository’s readme</a>. In summary, the compiler can handle:</p>
<ul>
  <li>Basic data types like <code class="language-plaintext highlighter-rouge">integer</code>, <code class="language-plaintext highlighter-rouge">real</code>, <code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">boolean</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">array</code>, <code class="language-plaintext highlighter-rouge">record</code> and <code class="language-plaintext highlighter-rouge">file</code></li>
  <li>Variable, constant, type alias, and subroutine (procedure / function) declaration</li>
  <li>Basic expression, subroutine call and control flow statement</li>
  <li>Internal declaration (e.g. procedure inside procedure) with local / global scoping</li>
  <li>A few standard library method call</li>
</ul>

<h3 id="generating-webassembly-binary">Generating WebAssembly binary</h3>
<p>I wanted the hangman game to be playable on a web page. There are three approaches<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> to do it: (1) make a virtual machine that interprets and runs the Pascal program, (2) transpile the Pascal program to Javascript and then run it using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function">Function object</a>, and (3) compile the Pascal program to WebAssembly. I chose the third option because I’m interested in WebAssembly for quite some time and it seems more fun and challenging than “just” making a VM or transpiling to Javascript.</p>

<p>While it is possible to just manually produce WebAssembly binary bytecodes, I used the <a href="https://github.com/AssemblyScript/binaryen.js/">binaryen-js</a> library because it’s easier and it also have validation and optimization features. The downside is that it is quite large, about 5 MB even after packed using parceljs. It also uses tree representation for validating and optimizing the WebAssembly module, so a few expressions like multivalue tuples and manual stack manipulation are a little bit harder to express. At the time I didn’t realize there’s also <a href="https://github.com/AssemblyScript/wabt.js">wabt.js</a>, so it is possible to produce WebAssembly code in text format first and then convert it to binary format.</p>

<h3 id="variables-and-call-stack">Variables and call stack</h3>
<p>WebAssembly has concept for <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#variable-instructions">local variable</a>, so locally-used variable can be implemented using it. However, it can only store integer or float value. For basic types the compiler can just directly use <code class="language-plaintext highlighter-rouge">f64</code> variable for real and <code class="language-plaintext highlighter-rouge">i32</code> variable for ordinals (integer, char, boolean), but for complex type like string, array, or record, it needs to maintain a call stack in the memory and store the address of the value as an <code class="language-plaintext highlighter-rouge">i32</code> local variable. Values in the call stack are allocated when a subroutine is called, and deallocated when the subroutine returns. The call stack is implemented in three parts:</p>
<ol>
  <li>Two global variable SP (stack pointer) and (FP) frame pointer. SP stores an address to top of value stack, and FP stores an address to top of call frame stack.</li>
  <li>Value stack, a region of the memory that stores complex type values.</li>
  <li>Call frame stack, a region of the memory that stores base address of the value stack for that call and subroutine id.</li>
</ol>

<p>Let’s look at the following Pascal program.</p>
<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">program</span> <span class="n">test</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">SmallStr</span> <span class="p">=</span> <span class="k">string</span><span class="p">[</span><span class="m">9</span><span class="p">];</span>
    <span class="k">var</span> <span class="n">str</span><span class="p">:</span> <span class="n">SmallStr</span><span class="p">;</span>
        <span class="n">x</span><span class="p">:</span> <span class="kt">integer</span><span class="p">;</span>

    <span class="k">procedure</span> <span class="n">a</span><span class="p">(</span><span class="n">strA</span><span class="p">:</span> <span class="n">SmallStr</span><span class="p">;</span> <span class="n">z</span><span class="p">:</span> <span class="kt">char</span><span class="p">);</span>
    <span class="k">begin</span>
        <span class="c1">// ...
</span>    <span class="k">end</span><span class="p">;</span>

    <span class="k">procedure</span> <span class="n">b</span><span class="p">(</span><span class="n">strB</span><span class="p">:</span> <span class="n">SmallStr</span><span class="p">);</span>
    <span class="k">var</span> <span class="n">strB1</span><span class="p">:</span> <span class="n">SmallStr</span><span class="p">;</span>
        <span class="n">y</span><span class="p">:</span> <span class="kt">boolean</span><span class="p">;</span>
    <span class="k">begin</span>
        <span class="c1">// ...
</span>        <span class="n">y</span> <span class="p">:=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">a</span><span class="p">(</span><span class="n">strB</span><span class="p">,</span> <span class="s">'a'</span><span class="p">);</span>
    <span class="k">end</span><span class="p">;</span>

<span class="k">begin</span>
    <span class="n">b</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="k">end</span><span class="p">.</span>
</code></pre></div></div>

<p>When procedure <code class="language-plaintext highlighter-rouge">a</code> is called, the call frame and value stack would look something like this in memory. Notice that variables <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> are not manually stored in the memory.</p>

<picture>
  <source srcset="/img/2021/budget-pascal-stack-dark.png" media="(prefers-color-scheme:dark)" />
  <img src="/img/2021/budget-pascal-stack.png" />
</picture>

<p>Things are a little more complicated for non-locally used variable; that is using variable declared by the parent scope or using variable as an argument to a var parameter. One big limitation of WebAssembly local variable is that it can’t be referenced as a pointer from outside of that function that declare it, so all non-locally used variable must be stored in memory regardless of the data type. For example, consider the following Pascal program.</p>
<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">program</span> <span class="n">test</span><span class="p">;</span>
    <span class="k">var</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="kt">integer</span><span class="p">;</span>

    <span class="k">procedure</span> <span class="n">outer</span><span class="p">(</span><span class="k">var</span> <span class="n">x</span><span class="p">:</span> <span class="kt">integer</span><span class="p">);</span>
        <span class="k">var</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">:</span> <span class="kt">integer</span><span class="p">;</span>

        <span class="k">procedure</span> <span class="n">inner</span><span class="p">();</span>
        <span class="k">var</span> <span class="n">z</span><span class="p">:</span> <span class="kt">integer</span><span class="p">;</span>
        <span class="k">begin</span>
            <span class="n">y1</span> <span class="p">:=</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// use y1 in inner
</span>            <span class="c1">// ...
</span>        <span class="k">end</span><span class="p">;</span>
    <span class="k">begin</span>
        <span class="n">x</span> <span class="p">:=</span> <span class="m">2</span><span class="p">;</span>
        <span class="n">inner</span><span class="p">();</span>
        <span class="c1">// ...
</span>    <span class="k">end</span><span class="p">;</span>

<span class="k">begin</span>
    <span class="n">outer</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span> <span class="c1">// use x1 as argument to a var parameter
</span><span class="k">end</span><span class="p">.</span>
</code></pre></div></div>
<p>Variable x1 and y1 will be stored in memory, while x2, y2 and z will be stored as WebAssembly local variables. The call frame and value stack will look like this when procedure <code class="language-plaintext highlighter-rouge">inner</code> is called.</p>

<picture>
  <source srcset="/img/2021/budget-pascal-stack-nonlocal-dark.png" media="(prefers-color-scheme:dark)" />
  <img src="/img/2021/budget-pascal-stack-nonlocal.png" />
</picture>

<h3 id="read-readln-and-other-async-operations">Read, ReadLn, and other async operations</h3>
<p>This part looked deceptively easy when it’s actually not. I wanted to emulate the terminal console on the web page. So naturally I used the <a href="https://xtermjs.org/">xterm.js</a> library. It’s not the easiest thing to use because I needed to manually handle the key and data event from the library, but it’s still way faster and easier than reimplementing a terminal UI. The terminal emulator worked!</p>

<p>This was the point where I realized that WebAssembly currently do not support call to asynchronous function or coroutines. If an imported function is an async function or a coroutine, it won’t pause execution to wait for the result. There is a way to handle this from inside the WebAssembly code using <a href="https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html">Asyncify</a>, but it involves call stack rewinding and is quite complicated. Instead, I used a combination of <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics">Atomics wait and notify</a> API. Basically, the compiled Pascal program is instantiated and executed inside a Web Worker. When there is an asynchronous call, such as readln, the web worker calls <code class="language-plaintext highlighter-rouge">Atomics.wait()</code> to pause itself. The main UI thread will call <code class="language-plaintext highlighter-rouge">Atomics.notify()</code> to the worker thread after a certain event is fired, in this case when a new line is read by the terminal emulator. So problem solved! Well, not quite yet.</p>

<p>It turned out that Atomics wait and notify API need SharedArrayBuffer to work, and SharedArrayBuffer is only enabled<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> if the page was <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#security_requirements">cross-origin isolated</a>. This is actually quite simple to achieve by adding extra headers to the top level document http response. Simple, if you have control of the server that serves the page. I didn’t have any active VPS at the time and I certainly didn’t have access to change response header in Github Page server. While VPS are quite cheap and easy to setup and I might need to use it for other purposes in the future, it’s still too much of a hassle and waste to set it up just for serving a static content. Luckily, I found <a href="https://dev.to/stefnotch/enabling-coop-coep-without-touching-the-server-2d3n">a blog post</a> by stefnotch that exactly solves my problem. The article has more detailed explanation, but it basically works by using a Service Worker to manually add the needed headers to the response.</p>

<h3 id="improvements">Improvements</h3>
<p>There are a lot of things that can be improved in my compiler implementation, but here are some of the more important ones.</p>
<ol>
  <li>I really should have the parser and the type checker &amp; resolver be seperated into different modules. I made it combined so that it only need two passes (parse + type check then emit binary) instead of three or more (parse, type check, then emit binary). It is faster but in hindsight it’s not that big of a difference and it makes the parser code more complex.</li>
  <li>The runtime library is currently always recompiled everytime a program is compiled. It shouldn’t be that hard to pre-compile it and then “copy” it to the compiled program, but I haven’t got the time. Also, I should have make the runtime library in higher-level language like C then compile it to WebAssembly, instead of making it manually in WebAssembly. There are some issues with that method (for example, the Pascal runtime will include C runtime and I need to remove it or handle it so it plays nicely), but I think it’s way much easier and better to do that if I were to made a serious compiler with a complete standard library.</li>
  <li>Handling messaging for async operations between the program runner worker thread and the main UI thread is quite a mess and tightly coupled. I haven’t got a good idea on how to tidy it up without going too generalized.</li>
</ol>

<h3 id="afterword">Afterword</h3>
<p>All in all I’m satisfied with the result of this project. I found WebAssembly to be an interesting compilation target, although there are definitely some growing pains which should be resolved in the future. I also found this project to be a good reminder of where I am now compared to where I was ten years ago. Hopefully, in another ten years I will see this project the way I see the old hangman game that started this project.</p>

<hr />

<h4 id="footnotes">Footnotes</h4>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>PTI-A class, for those who were pre-2012 ITB students. If I remember correctly, the class was reorganized into PTI-B and DasPro classes for CS &amp; EE students due to a syllabus change in 2012. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩︎︎</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>I’m fully aware that there is a way to <a href="https://wiki.freepascal.org/WebAssembly/Compiler">compile Pascal to WebAssembly using FreePascal</a> and maybe a lot more other ways, but I also want to make a compiler! <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩︎︎</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>This was originally not the case, until Meltdown and Spectre changed everything. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩︎︎</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Faiz Ilham</name></author><category term="compiler" /><category term="web-assembly" /><summary type="html"><![CDATA[TL;DR: I made a budget Pascal compiler to WebAssembly so that I can play a hangman game that my friends and I made 10 years ago. Check out the demo and the github repository.]]></summary></entry><entry><title type="html">Revisiting Chip-8</title><link href="https://faizilham.github.io/revisiting-chip8" rel="alternate" type="text/html" title="Revisiting Chip-8" /><published>2019-11-23T00:00:00+00:00</published><updated>2019-11-23T00:00:00+00:00</updated><id>https://faizilham.github.io/revisiting-chip8</id><content type="html" xml:base="https://faizilham.github.io/revisiting-chip8"><![CDATA[<p>It’s been a while since I write emulator projects. While I do want to make more “serious” emulator like
NES or GameBoy, I decided to do a warm up project by writing a <a href="/lab/chip8">Chip-8 emulator</a> once more.
Here are some interesting things I found and implemented during the development.</p>

<h3 id="dealing-with-flicker">Dealing with Flicker</h3>
<p>Chip-8 games are by nature flickery. This happens because in original Chip-8 the only way to move a sprite is by clearing screen
or erasing the sprite first, and then redraw it at the new position. Since it can only be done in two instructions,
it means the erase and the draw instruction may be seperated in different update-draw cycles, thus
results in flickering. This is even more pronounced when we consider that the CPU vs display speed ratio of Chip-8
is quite low (500:60 Hz, so 8-9 instructions/draw) and that there are usually several instructions seperating the erase and draw
instructions (e.g. for recalculating new sprite position without storing the old one).</p>

<p>There are some ways to deal with this. First, by not dealing with it and let it flicks. This is the easiest
method and actually accurate with the behavior of original Chip-8, but I want to do more here. Second,
by pooling the draw instruction to be actually drawn only after several instructions later, so that a pair of
erase-draw instruction is <em>probably</em> done in one actual draw. I don’t really like this approach since
it’s likely hard to get the right timing for every kinds of games or ROMs, and it can introduce visual
glitches in some edge cases.</p>

<p>The last method is by simulating the old phosphor screen behavior. Old phosphor screens have light decay time,
meaning that when a pixel is turned off from a previously turned on state it still gives off a fading afterglow
light for several milliseconds. I like this method since it only changes the behavior of the off pixels
and simulates the real screen behavior, so I implemented it. The result quite pleases me.</p>

<div class="center-piece">
    <div class="img-container">
    <img src="/img/2019/chip8_normal_ufo.gif" width="350" title="Normal flickery display" />
    <img src="/img/2019/chip8_phosphor_ufo.gif" width="350" title="Simulated phosphor screen display" />
    </div>
    Normal Flickery Display vs Simulated Phosphor Display
</div>

<h3 id="implementation-quirks">Implementation Quirks</h3>
<p>I used <a href="http://devernay.free.fr/hacks/chip8/C8TECH10.HTM">Cowgod’s Chip-8 Reference</a> as my primary reference
when I made my <a href="https://github.com/faizilham/chip8js">previous CHIP-8 project</a>. It turns out that there are some
implementation quirks that is documented as the original behavior in the reference, and my old emulator didn’t
handle it when games, especially older ones, expect the original behavior. In this project, I handled
three prominent quirks that can be toggled on or off by configuration.</p>

<ol>
  <li>
    <p>SHL &amp; SHR instruction quirk</p>

    <p>In the original Chip-8, instruction <code class="language-plaintext highlighter-rouge">8xy8</code> SHR and <code class="language-plaintext highlighter-rouge">8xyE</code> SHL should shift the value of register Vx by value
 of Vy, so that these instructions are interpreted as <code class="language-plaintext highlighter-rouge">Vx = Vx &gt;&gt; Vy</code> and <code class="language-plaintext highlighter-rouge">Vx = Vx &lt;&lt; Vy</code>.
 Some newer games mistakenly use this instruction as if it shift Vx by itself, i.e. <code class="language-plaintext highlighter-rouge">Vx = Vx &gt;&gt; Vx</code>
 and <code class="language-plaintext highlighter-rouge">Vx = Vx &lt;&lt; Vx</code>. Notable games with this quirky behavior are Tic-Tac-Toe and Space Invaders.</p>
  </li>
  <li>
    <p>Load &amp; Store Register instruction quirk</p>

    <p>In the original Chip-8, instruction <code class="language-plaintext highlighter-rouge">Fx55</code> and <code class="language-plaintext highlighter-rouge">Fx65</code> should store/load register the values of V0 to Vx
 into/from memory starting from address I, and then increment register I by x (<code class="language-plaintext highlighter-rouge">I = I + x</code>).
 Some newer games do not take into account the register I increment, and behaves as if I is not
 changed by these instructions. Tic-Tac-Toe and Space Invaders also have this quirk.</p>
  </li>
  <li>
    <p>Sprite wrapping</p>

    <p>The Cowgod’s reference said that a sprite partially drawn outside of display boundary will be
 wrapped around at the opposite end of the screen. This is not the <a href="http://laurencescotford.co.uk/?p=304">right behavior</a>.
 A sprite will be clipped if it’s partially drawn outside of display, but it will be wrapped around
 if <em>all</em> of the sprite is drawn outside of the display. I’m not really sure if there are any games that depend
 on sprite wrapping behavior, but I’ll give the option to do so.</p>
  </li>
</ol>

<h3 id="fx0a-wait-key-implementation">Fx0A Wait Key Implementation</h3>
<p>There are three instructions related to keypad input read: <code class="language-plaintext highlighter-rouge">Ex9E</code> skip if key Vx pressed, <code class="language-plaintext highlighter-rouge">ExA1</code> skip if key Vx
not pressed, and <code class="language-plaintext highlighter-rouge">Fx0A</code> wait until key is pressed and store to Vx. Instruction <code class="language-plaintext highlighter-rouge">Ex9E</code> and <code class="language-plaintext highlighter-rouge">ExA1</code> is just like that: skip
next instruction if key Vx is pressed / not pressed. For <code class="language-plaintext highlighter-rouge">Fx0A</code> however, the description is a bit misleading.
According to this <a href="https://retrocomputing.stackexchange.com/questions/358/how-are-held-down-keys-handled-in-chip-8">thread</a>
and <a href="http://laurencescotford.co.uk/?p=347">post</a>, the correct behavior of <code class="language-plaintext highlighter-rouge">Fx0A</code> is something like this:</p>

<ol>
  <li>Stop execution until a key is pressed</li>
  <li>When a key is pressed, store that key temporarily as K if K is not set. Execution is still stopped.</li>
  <li>When key K is released after it was pressed, store K to Vx, unset K and continue execution</li>
</ol>

<h3 id="rust-to-webassembly">Rust to WebAssembly</h3>
<p>I wrote my previous CHIP-8 emulator in C compiled to WebAssembly by using Emscripten. I used Rust compiled to WebAssembly
in this project, because I always want to try it. The rust-to-wasm compilation is done by using
<a href="https://github.com/rustwasm/wasm-pack">wasm-pack toolkit</a>.</p>

<p>I found the wasm-pack toolkit is quite easy to use. The resulting wasm file can also be integrated and bundled
easily using webpack. While I do like parcel more than webpack, unfortunately there are still some integration
issues between wasm-pack and parcel, so I just use webpack. Building the project is a two-step process:
(1) build the wasm file from Rust using wasm-pack, and (2) bundle the wasm file, Javascript loader, styles,
and other files using webpack.</p>

<p>I wrote the CPU and display buffer of the emulator in Rust. However, for the actual I/O parts like drawing
the display buffer to canvas, playing beep sound and reading key input, I still use Javascript.
I did this because currently WebAssembly can’t access DOM directly without moving some data from and into
the WebAssembly memory buffer. While wasm-pack can generate the bridge code easily, I don’t think the required data moving
is worth the performance than just directly using Javascript. In contrast, the Javascript code can directly read
WebAssembly memory buffer, so it doesn’t need to copy anything. I think this is the best solution
until WebAssembly can access DOM directly.</p>

<p>Another advantage of offloading the I/O codes from wasm to Javascript is size. In previous project, I used
SDL2 for drawing the canvas, playing beep sound and read key input. While using SDL2 is neat, it results
in a big-sized wasm file, since it also includes all the SDL2 library codes. For comparison, my old
emulator page size is around 5 MB, whereas the new emulator is under 100 KB.</p>

<h3 id="closure">Closure</h3>
<p>It’s been quite a fun revisiting the Chip-8 emulation. At first I wanted to extend the emulator
to include SuperChip instructions and increase the overall emulation accuracy, but I decided the effort
is best used in more “serious” emulator. I’m sure there are still some edge cases that my emulator can’t handle accurately.
For the next emulator, I’m probably going for the original Space Invaders on Taito 8080 arcade system, since it seems
quite easier to make than NES or GameBoy.</p>]]></content><author><name>Faiz Ilham</name></author><category term="emulator" /><category term="javascript" /><category term="rust" /><category term="web-assembly" /><summary type="html"><![CDATA[It’s been a while since I write emulator projects. While I do want to make more “serious” emulator like NES or GameBoy, I decided to do a warm up project by writing a Chip-8 emulator once more. Here are some interesting things I found and implemented during the development.]]></summary></entry></feed>