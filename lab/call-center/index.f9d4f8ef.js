let t;var e;let s;var i;(e=t||(t={}))[e.Int=4]="Int",e[e.Float=3]="Float",e[e.Bool=2]="Bool",e[e.String=7]="String",e[e.List=5]="List",e[e.Tuple=8]="Tuple",e[e.Option=6]="Option",e[e.Function=9]="Function",e[e.Custom=1]="Custom",e[e.None=0]="None",(i=s||(s={}))[i.Int=t.Int]="Int",i[i.Float=t.Float]="Float",i[i.Bool=t.Bool]="Bool",i[i.String=t.String]="String",i[i.None=t.None]="None";class r{constructor(e){this.elementType=e,this.kind=t.List,this.typelabel=this.kind.toString()+m(e),this.typename=E(e)+"[]"}}class a{constructor(e){this.productTypes=e,this.kind=t.Tuple,this.typelabel=this.kind.toString()+d(e.length.toString(),2)+e.map(m),this.typename=`(${e.map(E).join(", ")})`}}class n{constructor(e){this.kind=t.Option,this.sumTypes=[];for(let t of e)if(y(t))for(let e of t.sumTypes)o(e,this.sumTypes)||this.sumTypes.push(e);else o(t,this.sumTypes)||this.sumTypes.push(t);this.typelabel=this.kind.toString()+d(e.length.toString(),2)+e.map(m),this.typename=e.map(E).join(" | ")}}function o(t,e){for(let s of e)if(p(s,t))return!0;return!1}class h{constructor(e,s){this.returnType=e,this.paramTypes=s,this.kind=t.Function,this.typelabel=this.kind.toString()+d(s.length.toString(),2)+s.map(m)+m(e),this.typename=`Func (${s.map(E).join(", ")}) -> ${E(e)}`}}function p(t,e){return u(t)?!!u(e)&&t===e:!u(e)&&t.typelabel===e.typelabel}function u(t){return!isNaN(t)}function c(e){return e.kind===t.List}function l(e){return e.kind===t.Tuple}function y(e){return e.kind===t.Option}function w(e){return e.kind===t.Function}function f(t,e){if(p(t,e))return!0;if(!y(t))return!1;if(!y(e)){for(let s of t.sumTypes)if(f(s,e))return!0;return!1}for(let s of e.sumTypes){let e=!1;for(let i of t.sumTypes)if(f(i,s)){e=!0;break}if(!e)return!1}return!0}function m(t){return u(t)?t.toString():t.typelabel}function E(t){if(!u(t))return t.typename;switch(t){case s.Bool:return"bool";case s.Int:return"int";case s.Float:return"float";case s.String:return"string";default:return"none"}}function d(t,e){return function(t,e,s){return s.repeat(e-t.length)+t}(t,e,"0")}class T{constructor(t,e,s){this.type=t,this.originalType=e,this.value=s}toString(){return v(this.value)}}class g{constructor(t,e,s){this.name=t,this.type=e,this.body=s}toString(){return"[Function]"}}function v(t){return null==t?"None":t.toString()}let x;var S;let N;(S=x||(x={}))[S.ADD=233]="ADD",S[S.SUB=782]="SUB",S[S.MUL=685]="MUL",S[S.DIV=348]="DIV",S[S.MOD=663]="MOD",S[S.EQ=37]="EQ",S[S.NE=63]="NE",S[S.LT=58]="LT",S[S.GT=48]="GT",S[S.LTE=583]="LTE",S[S.GTE=483]="GTE",S[S.AND=263]="AND",S[S.OR=67]="OR",S[S.INT=468]="INT",S[S.FLO=356]="FLO",S[S.STR=787]="STR",S[S.NEG=634]="NEG",S[S.NOT=668]="NOT",S[S.LIST=5478]="LIST",S[S.APP=277]="APP",S[S.SAPP=-277]="SAPP",S[S.GET=438]="GET",S[S.SGET=-438]="SGET",S[S.SET=738]="SET",S[S.SSET=-738]="SSET",S[S.LEN=536]="LEN",S[S.CHRS=2488]="CHRS",S[S.TUP=887]="TUP",S[S.TGET=8438]="TGET",S[S.TSET=8738]="TSET",S[S.IF=43]="IF",S[S.FUNCALL=1]="FUNCALL",S[S.GETVAR=0]="GETVAR",S[S.LET=538]="LET",S[S.IFL=435]="IFL",S[S.NUMBER=-1]="NUMBER",S[S.TRANSFORM_OPT=-2]="TRANSFORM_OPT",function(t){t.NumberExpr=class{constructor(t){this.number=t,this.kind=x.NUMBER,this.type=s.Int}};t.BinaryMath=class{constructor(t,e,s,i){this.kind=t,this.type=e,this.left=s,this.right=i}};t.Comparison=class{constructor(t,e,i){this.kind=t,this.left=e,this.right=i,this.type=s.Bool}};t.LogicCircuit=class{constructor(t,e,i){this.kind=t,this.left=e,this.right=i,this.type=s.Bool}};t.TypeConversion=class{constructor(t,e,s){this.kind=t,this.type=e,this.expr=s}};t.Unary=class{constructor(t,e,s){this.kind=t,this.type=e,this.expr=s}};t.ListCons=class{constructor(t,e){this.type=t,this.elements=e,this.kind=x.LIST}};t.Append=class{constructor(t,e,s,i){this.kind=t,this.type=e,this.left=s,this.right=i}};t.Get=class{constructor(t,e,s,i){this.kind=t,this.type=e,this.list=s,this.index=i}};t.Set=class{constructor(t,e,s,i,r){this.kind=t,this.type=e,this.list=s,this.index=i,this.value=r}};t.Len=class{constructor(t){this.value=t,this.kind=x.LEN,this.type=s.Int}};t.Chrs=class{constructor(t){this.value=t,this.kind=x.CHRS,this.type=s.String}};t.Tuple=class{constructor(t,e){this.type=t,this.values=e,this.kind=x.TUP}};t.IfExpr=class{constructor(t,e,s,i){this.type=t,this.cond=e,this.trueVal=s,this.falseVal=i,this.kind=x.IF}};t.FunCall=class{constructor(t,e,s){this.type=t,this.func=e,this.args=s,this.kind=x.FUNCALL}};t.GetVar=class{constructor(t,e){this.type=t,this.id=e,this.kind=x.GETVAR}};t.Let=class{constructor(t,e,s,i){this.type=t,this.id=e,this.value=s,this.inExpr=i,this.kind=x.LET}};t.OptTransform=class{constructor(t,e,s){this.type=t,this.originalType=e,this.value=s,this.kind=x.TRANSFORM_OPT}};t.IfLet=class{constructor(t,e,s,i,r,a){this.type=t,this.id=e,this.convertType=s,this.value=i,this.trueVal=r,this.falseVal=a,this.kind=x.IFL}}}(N||(N={}));const b=1e3;function L(){return new Error("unreachable")}async function I(t,e){const s=new k(t,e);await s.run()}class A{constructor(t){this.parent=t,this.vars=new Map,this.funcs=new Map,this.types=new Map}getVar(t){let e=this.vars.get(t);return e||(this.parent?this.parent.getVar(t):void 0)}setVar(t,e,s){this.vars.set(t,[e,s])}getFunc(t){let e=this.funcs.get(t);return e||(this.parent?this.parent.getFunc(t):void 0)}setFunc(t,e){this.funcs.set(t,e)}getType(t){let e=this.types.get(t);return e||(this.parent?this.parent.getType(t):void 0)}setType(t,e){this.types.set(t,e)}}class k{constructor(t,e){this.src=t,this.output=e,this.env=new A,this.parser=new D(t,e,this.env)}log(t){return this.output.log(t)}async run(){try{let t=!1;this.log("Welcome to the call center interpreter!");do{t=await this.runLine()}while(!t)}catch(t){t===b?await this.log("Call ended abruptly. Thank you for using the call center interpreter!"):await this.output.err(t)}finally{this.src.close()}}async runLine(){switch(this.log("To define a function, press 1. To define a type, press 2.\nTo evaluate an expression, press 3. To end the call, press 0."),await this.parser.next()){case"1":await this.log("Please input your function definition."),await this.interpretFunctionDef();break;case"2":await this.log("Please input your type definition."),await this.interpretTypeDef();break;case"3":await this.log("Please input your expression."),await this.interpretExpression();break;case"0":return await this.log("Thank you for using the call center interpreter!"),!0;default:await this.log("Sorry, that option is invalid.")}return!1}async interpretExpression(){let t=!1;try{this.parser.resetCursor();let e=await this.parser.parseExpression();t=!0,await this.parser.consumeHash();let s=await this.visitExpr(e);null!=s&&(this.log("The expression is evaluated to: "),this.output.out(F(s)))}catch(e){this.handleError(t,e)}}async interpretFunctionDef(){let t=!1;try{this.parser.resetCursor(),await this.parser.parseFunctionDefinition(),t=!0,await this.parser.consumeHash(),this.log("Function is now declared.")}catch(e){this.handleError(t,e)}}async interpretTypeDef(){let t=!1;try{this.parser.resetCursor(),await this.parser.parseTypeDefinition(),t=!0,await this.parser.consumeHash(),this.log("Type is now declared.")}catch(e){this.handleError(t,e)}}async visitExpr(t){switch(t.kind){case x.NUMBER:return t.number;case x.ADD:return await this.visitExprAsNumber(t.left)+await this.visitExprAsNumber(t.right);case x.SUB:return await this.visitExprAsNumber(t.left)-await this.visitExprAsNumber(t.right);case x.MUL:return await this.visitExprAsNumber(t.left)*await this.visitExprAsNumber(t.right);case x.DIV:{let e=await this.visitExprAsNumber(t.left),i=await await this.visitExprAsNumber(t.right);0===i&&await this.runtimeError("division by zero");let r=e/i;return t.type===s.Int&&(r=Math.floor(r)),r}case x.MOD:{let e=await this.visitExprAsNumber(t.left),s=await await this.visitExprAsNumber(t.right);return 0===s&&await this.runtimeError("division by zero"),e%s}case x.EQ:return 0===C(await this.visitExpr(t.left),await this.visitExpr(t.right));case x.NE:return 0!==C(await this.visitExpr(t.left),await this.visitExpr(t.right));case x.LT:return C(await this.visitExpr(t.left),await this.visitExpr(t.right))<0;case x.GT:return C(await this.visitExpr(t.left),await this.visitExpr(t.right))>0;case x.LTE:return C(await this.visitExpr(t.left),await this.visitExpr(t.right))<=0;case x.GTE:return C(await this.visitExpr(t.left),await this.visitExpr(t.right))>=0;case x.AND:case x.OR:{let e=await this.visitExprAsBool(t.left);return!(t.kind===x.AND&&!e)&&(!(t.kind!==x.OR||!e)||await this.visitExprAsBool(t.right))}case x.INT:case x.FLO:return await this.visitExprAsNumber(t.expr);case x.STR:return v(await this.visitExpr(t.expr));case x.NOT:return!await this.visitExprAsBool(t.expr);case x.NEG:return-await this.visitExprAsNumber(t.expr);case x.LIST:{let e=[];for(let s of t.elements)e.push(await this.visitExpr(s));return e}case x.APP:{let e=await this.visitExpr(t.left),s=await this.visitExpr(t.right);return c(t.left.type)?c(t.right.type)?e.concat(s):(e.push(s),e):(s.unshift(e),s)}case x.SAPP:{let e=await this.visitExpr(t.left),i=await this.visitExpr(t.right);return t.left.type===s.Int?e=String.fromCharCode(e%256):t.right.type===s.Int&&(i=String.fromCharCode(i%256)),e+i}case x.GET:case x.SGET:case x.TGET:{let e=await this.visitExpr(t.list),s=await this.visitExprAsNumber(t.index);return(s<0||s>=e.length)&&await this.runtimeError("index out of bound"),e[s]}case x.SET:case x.TSET:{let e=await this.visitExpr(t.list),s=await this.visitExprAsNumber(t.index),i=await this.visitExpr(t.value);return(s<0||s>=e.length)&&await this.runtimeError("index out of bound"),e[s]=i,e}case x.SSET:{let e=await this.visitExpr(t.list),i=await this.visitExprAsNumber(t.index),r=await this.visitExpr(t.value);return(i<0||i>=e.length)&&await this.runtimeError("index out of bound"),t.value.type===s.Int&&(r=String.fromCharCode(r)),e.substring(0,i)+r[0]+e.substring(i+1)}case x.LEN:return(await this.visitExpr(t.value)).length;case x.CHRS:return(await this.visitExpr(t.value)).map((t=>String.fromCharCode(t))).join("");case x.TUP:{let e=[];for(let s of t.values)e.push(await this.visitExpr(s));return e}case x.IF:{let e=await this.visitExprAsBool(t.cond)?t.trueVal:t.falseVal;return await this.visitExpr(e)}case x.FUNCALL:{let e=this.env,s=new A(e);for(let e=0;e<t.args.length;e++){let i=t.args[e],r=await this.visitExpr(i);s.setVar(e,i.type,r)}try{return this.env=s,await this.visitExpr(t.func.body)}finally{this.env=e}}case x.GETVAR:{let e=this.env.getVar(t.id);if(!e)throw await this.runtimeError(`Missing variable #${t.id}`),L();return e[1]}case x.LET:{let e=await this.visitExpr(t.value),s=this.env,i=new A(s);i.setVar(t.id,t.value.type,e);try{return this.env=i,await this.visitExpr(t.inExpr)}finally{this.env=s}}case x.TRANSFORM_OPT:{let e=await this.visitExpr(t.value);return new T(t.type,t.originalType,e)}case x.IFL:{let e=await this.visitExpr(t.value);if(!(e instanceof T))throw await this.runtimeError("option value corrupted"),L();if(!f(t.convertType,e.originalType))return await this.visitExpr(t.falseVal);e=y(t.convertType)?new T(t.convertType,e.originalType,e.value):e.value;let s=this.env,i=new A(s);i.setVar(t.id,t.convertType,e);try{return this.env=i,await this.visitExpr(t.trueVal)}finally{this.env=s}}}throw L()}async visitExprAsNumber(t){return await this.visitExpr(t)}async visitExprAsBool(t){return await this.visitExpr(t)}async handleError(t,e){switch(e){case 1001:if(t)return void this.parser.next();for(;"#"!==await this.parser.peek();)await this.parser.next();await this.parser.next();break;case 1002:break;default:throw e}}async runtimeError(t){throw await this.output.err("Sorry, we found a runtime error: "+t),1002}}function F(t){if("string"==typeof t)return`"${t}"`;if(t instanceof T)return F(t.value);if(Array.isArray(t)){return`[${t.map(F).join(",")}]`}return v(t)}function C(t,e){return Array.isArray(t)?$(t,e):O(t,e)}function O(t,e){if(null==t)return 0;return t<e?-1:t>e?1:0}function $(t,e){const s=Math.min(t.length,e.length);for(let i=0;i<s;i++)if(Array.isArray(t[i])){let s=$(t[i],e[i]);if(0!==s)return s}else{let s=O(t[i],e[i]);if(0!==s)return s}return t.length<e.length?-1:t.length>e.length?1:0}class D{constructor(t,e,s){this.src=t,this.output=e,this.env=s,this.cursor=0}resetCursor(){this.cursor=0}async next(){await this.peek();let t=await this.src.next();if(!t)throw b;return this.cursor++,t}async peek(){for(;;){let t=await this.src.peek();if(!t)throw b;if(/[0-9\*\#]/.test(t))return t;await this.src.next()}}async parseError(t,e){throw null!=e&&(this.cursor=e),await this.output.err(`Sorry, we found an error at character ${this.cursor+1} while parsing: ${t}`),1001}async parseTypeDefinition(){await this.consumeStar();let t=this.cursor;1!==await this.consumeDigit()&&await this.parseError("Custom type must start with 1",t);let e=1e3+100*await this.consumeDigit()+10*await this.consumeDigit()+await this.consumeDigit();await this.consumeStar();let s=await this.parseType();this.env.setType(e,s)}async parseType(){switch(await this.consumeDigit()){case t.Int:return s.Int;case t.Float:return s.Float;case t.Bool:return s.Bool;case t.String:return s.String;case t.None:return s.None;case t.List:return this.parseTypeList();case t.Tuple:return this.parseTypeTuple();case t.Option:return this.parseTypeOption();case t.Function:return this.parseTypeFunction();case t.Custom:return this.parseTypeCustom()}throw L()}async parseTypeList(){let t=await this.parseType();return new r(t)}async parseTypeTuple(){let t=this.cursor,e=10*await this.consumeDigit()+await this.consumeDigit();e<2&&await this.parseError("tuple must have at least 2 element types.",t);let s=[];for(let t=0;t<e;t++)s.push(await this.parseType());return new a(s)}async parseTypeOption(){let t=this.cursor,e=10*await this.consumeDigit()+await this.consumeDigit();e<2&&await this.parseError("options must have at least 2 choice types.",t);let s=[];for(let t=0;t<e;t++)s.push(await this.parseType());return new n(s)}async parseTypeFunction(){let t=10*await this.consumeDigit()+await this.consumeDigit(),e=[];for(let s=0;s<t;s++)e.push(await this.parseType());let s=await this.parseType();return new h(s,e)}async parseTypeCustom(){let t=1e3+100*await this.consumeDigit()+10*await this.consumeDigit()+await this.consumeDigit(),e=this.env.getType(t);if(null==e)throw await this.parseError(`unknown declared type with id ${e}.`),L();return e}async parseFunctionDefinition(){await this.consumeStar();let t=parseInt(await this.consumeNumber(),10);await this.consumeStar();let e=this.cursor,s=parseInt(await this.consumeNumber(),10);s>99&&await this.parseError("Function can only have at max 99 paramters.",e);let i=[];for(let t=0;t<s;t++)await this.consumeStar(),i.push(await this.parseType());await this.consumeStar();let r=await this.parseType(),a=new h(r,i),n=new g(t,a,new N.NumberExpr(0)),o=this.env,p=new A(o);p.setFunc(t,n);for(let t=0;t<s;t++)p.setVar(t,i[t],null);try{this.env=p,await this.consumeStar(),e=this.cursor;let s=await this.parseExpression();f(r,s.type)||await this.parseError(`unable to assign type ${E(s.type)} for return type ${E(r)}.`),s=this.transformOpt(r,s),n.body=s,o.setFunc(t,n)}finally{this.env=o}}async parseExpression(){return"*"===await this.peek()?this.parseInstruction():this.parseNumber()}async parseInstruction(){await this.consumeStar();let t=await this.consumeNumber();if(t.startsWith(x.GETVAR.toString()))return this.parseGetVar(t);if(t.startsWith(x.FUNCALL.toString()))return this.parseFunCall(t);let e=parseInt(t,10);switch(e){case x.ADD:case x.SUB:case x.MUL:case x.DIV:case x.MOD:return this.parseBinaryMath(e);case x.EQ:case x.NE:case x.LT:case x.GT:case x.LTE:case x.GTE:return this.parseCompare(e);case x.AND:case x.OR:return this.parseLogic(e);case x.INT:case x.FLO:case x.STR:return this.parseConversion(e);case x.NEG:case x.NOT:return this.parseUnary(e);case x.LIST:return this.parseListCons();case x.APP:return this.parseAppend();case x.GET:return this.parseLSGet();case x.SET:return this.parseLSSet();case x.LEN:return this.parseLen();case x.CHRS:return this.parseChrs();case x.TUP:return this.parseTup();case x.TGET:return this.parseTget();case x.TSET:return this.parseTset();case x.IF:return this.parseIf();case x.LET:return this.parseLet();case x.IFL:return this.parseIfLet()}throw await this.parseError(`unknown instruction ${t}`),L()}async parseIf(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();e.type!==s.Bool&&await this.parseError(`invalid type ${E(e.type)} for if condition expression.`,t),await this.consumeStar();let i=await this.parseExpression();await this.consumeStar();let r=await this.parseExpression(),a=i.type;return p(i.type,r.type)||(a=new n([i.type,r.type])),new N.IfExpr(a,e,i,r)}async parseFunCall(t){let e=this.cursor-t.length;t.length<2&&await this.parseError("invalid function call format.",e);let s=parseInt(t.slice(1),10),i=this.env.getFunc(s);if(!i)throw await this.parseError(`unknown function with id ${s}`,e+1),L();e=this.cursor;let r=i.type.paramTypes.length,a=await this.parseArgs(r);for(let t=0;t<r;t++){let s=i.type.paramTypes[t],r=a[t];f(s,r.type)||await this.parseError(`unable to assign argument with type ${E(r.type)} to parameter of type ${E(s)}`,e),a[t]=this.transformOpt(s,r)}return new N.FunCall(i.type.returnType,i,a)}async parseGetVar(t){let e=this.cursor-t.length;t.length<2&&await this.parseError("invalid get var format.",e);let s=parseInt(t.slice(1),10),i=this.env.getVar(s);if(!i)throw await this.parseError(`unknown function with id ${s}`,e+1),L();let r=i[0];return new N.GetVar(r,s)}async parseLet(){await this.consumeStar();let t=parseInt(await this.consumeNumber(),10);await this.consumeStar();let e=await this.parseExpression(),s=this.env,i=new A(s);i.setVar(t,e.type,null);try{this.env=i,await this.consumeStar();let s=await this.parseExpression();return new N.Let(s.type,t,e,s)}finally{this.env=s}}async parseIfLet(){await this.consumeStar();let t=parseInt(await this.consumeNumber(),10);await this.consumeStar();let e=await this.parseType();await this.consumeStar();let s=this.cursor,i=await this.parseExpression();y(i.type)?f(i.type,e)||await this.parseError(`unable to derive type ${E(e)} from ${E(i.type)}.`,s):await this.parseError(`invalid use of iflet from value of type ${E(i.type)} instead of an option type.`,s);let r,a=this.env,o=new A(a);o.setVar(t,e,null);try{this.env=o,await this.consumeStar(),r=await this.parseExpression()}finally{this.env=a}await this.consumeStar();let h=await this.parseExpression(),u=r.type;return p(r.type,h.type)||(u=new n([r.type,h.type])),new N.IfLet(u,t,e,i,r,h)}async parseTup(){await this.consumeStar();let t=this.cursor,e=parseInt(await this.consumeNumber(),10)||0;(e<2||e>99)&&await this.parseError("tuple size must be between 2-99 elements.",t);let s=await this.parseArgs(e),i=new a(s.map((t=>t.type)));return new N.Tuple(i,s)}async parseTget(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();if(!l(e.type))throw await this.parseError(`unable to do tuple get operation for type ${E(e.type)}`,t),L();await this.consumeStar(),t=this.cursor;let s=parseInt(await this.consumeNumber(),10);(s<0||s>=e.type.productTypes.length)&&await this.parseError(`invalid tuple index ${s}`,t);let i=e.type.productTypes[s],r=new N.NumberExpr(s);return new N.Get(x.TGET,i,e,r)}async parseTset(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();if(!l(e.type))throw await this.parseError(`unable to do tuple get operation for type ${E(e.type)}`,t),L();await this.consumeStar(),t=this.cursor;let s=parseInt(await this.consumeNumber(),10);(s<0||s>=e.type.productTypes.length)&&await this.parseError(`invalid tuple index ${s}`,t);let i=e.type.productTypes[s];await this.consumeStar(),t=this.cursor;let r=await this.parseExpression();f(i,r.type)||await this.parseError(`unable to do set tuple operation between types ${E(i)} and ${E(r.type)}.`),r=this.transformOpt(i,r);let a=new N.NumberExpr(s);return new N.Set(x.TSET,e.type,e,a,r)}async parseListCons(){await this.consumeStar();let t=await this.parseType();await this.consumeStar();let e=parseInt(await this.consumeNumber(),10)||0,s=this.cursor,i=await this.parseArgs(e);for(let e=0;e<i.length;e++){let r=i[e];f(t,r.type)||await this.parseError(`type ${E(r.type)} is not assignable to list of element type ${E(t)}`,s),i[e]=this.transformOpt(t,r)}return new N.ListCons(new r(t),i)}async parseAppend(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();await this.consumeStar();let s=await this.parseExpression();return c(e.type)||c(s.type)?this.parseAppendList(t,e,s):this.parseAppendStr(t,e,s)}async parseAppendList(t,e,i){let r=s.None;return c(e.type)?p(e.type,i.type)?r=e.type:f(e.type.elementType,i.type)&&(r=e.type,i=this.transformOpt(r.elementType,i)):c(i.type)&&f(i.type.elementType,e.type)&&(r=i.type,e=this.transformOpt(r.elementType,e)),r===s.None&&await this.parseError(`unable to do append list operation between types ${E(e.type)} and ${E(i.type)}`,t),new N.Append(x.APP,r,e,i)}async parseAppendStr(t,e,i){let r=s.None;return(e.type===s.String&&i.type===s.String||e.type===s.String&&i.type===s.Int||e.type===s.Int&&i.type===s.String)&&(r=s.String),r===s.None&&await this.parseError(`unable to do append operation between types ${E(e.type)} and ${E(i.type)}`,t),new N.Append(x.SAPP,r,e,i)}async parseLSGet(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();await this.consumeStar();let i=this.cursor,r=await this.parseExpression();r.type!==s.Int&&await this.parseError(`index in get operation must be of type ${E(s.Int)}, instead of ${E(r.type)}`,i);let a=s.None,n=x.GET;return e.type===s.String?(a=s.String,n=x.SGET):c(e.type)&&(a=e.type.elementType),a===s.None&&await this.parseError(`unable to do get operation for type ${E(e.type)}`,t),new N.Get(n,a,e,r)}async parseLSSet(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();await this.consumeStar();let i=this.cursor,r=await this.parseExpression();r.type!==s.Int&&await this.parseError(`index in get operation must be of type ${E(s.Int)}, instead of ${E(r.type)}`,i),await this.consumeStar();let a=await this.parseExpression(),n=s.None,o=x.SET;return e.type!==s.String||a.type!==s.String&&a.type!==s.Int?c(e.type)&&f(e.type.elementType,a.type)&&(n=e.type,a=this.transformOpt(n.elementType,a)):(n=s.String,o=x.SSET),n===s.None&&await this.parseError(`unable to do set operation for types ${E(e.type)} and ${E(a.type)}`,t),new N.Set(o,n,e,r,a)}async parseLen(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();return e.type===s.String||c(e.type)||await this.parseError(`unable to do len operation for type ${E(e.type)}`,t),new N.Len(e)}async parseChrs(){await this.consumeStar();let t=this.cursor,e=await this.parseExpression();if(c(e.type)&&e.type.elementType===s.Int)return new N.Chrs(e);throw await this.parseError(`unable to do chars operation for type ${E(e.type)}`,t),L()}async parseArgs(t){let e=[];for(let s=0;s<t;s++)await this.consumeStar(),e.push(await this.parseExpression());return e}async parseBinaryMath(t){await this.consumeStar();let e=this.cursor,i=await this.parseExpression();await this.consumeStar();let r=await this.parseExpression(),a=s.None;switch(i.type){case s.Int:switch(r.type){case s.Int:a=s.Int;break;case s.Float:a=s.Float}break;case s.Float:switch(r.type){case s.Int:case s.Float:a=s.Float}}return a===s.None&&await this.parseError(`unable to do math operation between types ${E(i.type)} and ${E(r.type)}`,e),new N.BinaryMath(t,a,i,r)}async parseCompare(t){await this.consumeStar();let e=this.cursor,s=await this.parseExpression();await this.consumeStar();let i=await this.parseExpression();return(w(s.type)||w(i.type)||!p(s.type,i.type))&&await this.parseError(`unable to do comparison between types ${E(s.type)} and ${E(i.type)}`,e),new N.Comparison(t,s,i)}async parseLogic(t){await this.consumeStar();let e=this.cursor,i=await this.parseExpression();await this.consumeStar();let r=await this.parseExpression();return i.type===s.Bool&&r.type===s.Bool||await this.parseError(`unable to do logic operator between types ${E(i.type)} and ${E(r.type)}`,e),new N.LogicCircuit(t,i,r)}async parseConversion(t){await this.consumeStar();let e=this.cursor,i=await this.parseExpression(),r=s.None,a=s.None;switch(t){case x.INT:a=s.Int,i.type===s.Float&&(r=a);break;case x.FLO:a=s.Float,i.type===s.Int&&(r=a);break;case x.STR:a=s.String,r=a}return r===s.None&&await this.parseError(`unable to do conversion from type ${E(i.type)} into ${E(a)}`,e),new N.TypeConversion(t,r,i)}async parseUnary(t){await this.consumeStar();let e=this.cursor,i=await this.parseExpression(),r=s.None;return t!==x.NEG||i.type!==s.Int&&i.type!==s.Float?t===x.NOT&&i.type===s.Bool&&(r=s.Bool):r=i.type,r===s.None&&await this.parseError(`invalid operation for type ${E(i.type)}`,e),new N.Unary(t,r,i)}transformOpt(t,e){return y(t)&&!y(e.type)?new N.OptTransform(t,e.type,e):e}async parseNumber(){let t=parseInt(await this.consumeNumber(),10);return new N.NumberExpr(t)}async consumeStar(){"*"!==await this.peek()&&await this.parseError("expected asterisk."),await this.next()}async consumeHash(){"#"!==await this.peek()&&await this.parseError("expected hash at the end of declaration."),await this.next()}async consumeDigit(){return/[0-9]/.test(await this.peek())||await this.parseError("expected digit."),parseInt(await this.next(),10)}async consumeNumber(){let t=[];for(;/[0-9]/.test(await this.peek());)t.push(await this.next());return 0===t.length&&await this.parseError("expected number."),t.join("")}}const G=window.AudioContext||window.webkitAudioContext||window.mozAudioContext;class P{constructor(t,e,s){this.context=t,this.freq1=e,this.freq2=s,this.status=0,this.osc1=this.context.createOscillator(),this.osc2=this.context.createOscillator(),this.osc1.frequency.value=this.freq1,this.osc2.frequency.value=this.freq2,this.gainNode=this.context.createGain(),this.gainNode.gain.value=.25,this.filter=this.context.createBiquadFilter(),this.filter.type="lowpass",this.filter.frequency.value=8e3,this.osc1.connect(this.gainNode),this.osc2.connect(this.gainNode),this.gainNode.connect(this.filter),this.filter.connect(this.context.destination)}start(){this.setup(),this.osc1.start(0),this.osc2.start(0),this.status=1}stop(){this.osc1.stop(0),this.osc2.stop(0),this.status=0}setup(){this.osc1=this.context.createOscillator(),this.osc2=this.context.createOscillator(),this.osc1.frequency.value=this.freq1,this.osc2.frequency.value=this.freq2,this.gainNode=this.context.createGain(),this.gainNode.gain.value=.25,this.filter=this.context.createBiquadFilter(),this.filter.type="lowpass",this.osc1.connect(this.gainNode),this.osc2.connect(this.gainNode),this.gainNode.connect(this.filter),this.filter.connect(this.context.destination)}}var B={1:{f1:697,f2:1209},2:{f1:697,f2:1336},3:{f1:697,f2:1477},4:{f1:770,f2:1209},5:{f1:770,f2:1336},6:{f1:770,f2:1477},7:{f1:852,f2:1209},8:{f1:852,f2:1336},9:{f1:852,f2:1477},"*":{f1:941,f2:1209},0:{f1:941,f2:1336},"#":{f1:941,f2:1477}};const V=G?new G:null;function R(t,e){if(!V)return Promise.resolve();const s=B[t],i=new P(V,s.f1,s.f2);return 0==i.status&&i.start(),new Promise((t=>{setTimeout((()=>{i.stop(),t()}),e)}))}function U(t,e,s){let i=document.createElement("div");return i.setAttribute("class",e),i.innerText=s,t.appendChild(i),i}class M{constructor(t,e,s){this.input=t,this.output=e,this.synth=s,this.buffer="",this.lastConsole=null,this.isOutput=!0,this.voice=null,this.speechPromise=null,this.reset(),this.initSynth()}reset(){this.speechPromise=null,this.isOutput=!0,this.lastConsole=null,this.buffer=this.input.value||"",this.output.innerHTML=""}initSynth(){this.synth&&(this.getVoice(this.synth)||(this.synth=null))}getVoice(t){const e=t.getVoices().filter((t=>"en-US"===t.lang));return 0===e.length?null:(this.voice=e.find((t=>/google/i.test(t.name)))||e.find((t=>/microsoft/i.test(t.name)&&/aria/i.test(t.name)))||e.find((t=>/microsoft/i.test(t.name)&&/zira/i.test(t.name)))||e[0],this.voice)}addOutput(t,e){if(this.lastConsole)if(this.isOutput!==t){this.isOutput=t;const s=t?"console-out":"console-in";this.lastConsole=U(this.output,s,e)}else this.lastConsole.innerText=this.lastConsole.innerText+e;else{this.isOutput=t;const s=t?"console-out":"console-in";this.lastConsole=U(this.output,s,e)}}speak(t){if(!this.synth||!this.voice)return Promise.resolve();const e=new SpeechSynthesisUtterance(t);e.voice=this.voice;const s=new Promise((t=>{e.onend=()=>{this.speechPromise=null,t()}}));return this.speechPromise=s,this.synth.speak(e),s}async log(t){this.addOutput(!1,t+"\n"),await this.speak(t)}async out(t){let e=t||"";this.addOutput(!1,e+"\n"),await this.speak(e)}async err(t){let e=t||"";this.addOutput(!1,e+"\n"),await this.speak(e)}async next(){if(0===this.buffer.length)return null;this.speechPromise&&await this.speechPromise;let t=this.buffer[0];return this.buffer=this.buffer.slice(1),/[0-9\*\#]/.test(t)&&(await R(t,200),this.addOutput(!0,t)),t}async peek(){return 0===this.buffer.length?null:this.buffer[0]}close(){}}function q(){let t=document.getElementById("editor"),e=document.getElementById("console"),s=document.getElementById("call"),i=new M(t,e,window.speechSynthesis);s.addEventListener("click",(t=>{s.setAttribute("disabled","true"),i.reset(),I(i,i).then((()=>{s.removeAttribute("disabled")}))}))}window.speechSynthesis&&0===window.speechSynthesis.getVoices().length?window.speechSynthesis.onvoiceschanged=()=>{q()}:q();