var e,r;(r=e||(e={}))[r.OK=1]="OK",r[r.NOT_FOUND=2]="NOT_FOUND",r[r.CLOSED=3]="CLOSED",r[r.ALREADY_OPENED=4]="ALREADY_OPENED",r[r.NOT_ASSIGNED=5]="NOT_ASSIGNED",r[r.READONLY=6]="READONLY",r[r.WRITEONLY=7]="WRITEONLY",r[r.WRITE_ERROR=8]="WRITE_ERROR",r[r.FILE_ENDED=9]="FILE_ENDED";class t extends Error{}class n extends Error{constructor(e){super(`Runtime error: ${e}`)}}function o(e){const r=e.match(/^\s+/);return r?e.slice(r[0].length):e}function i(e){const r=e.match(/^[^\s]+/);return r?[r[0],e.slice(r[0].length)]:["",e]}const s={[e.NOT_FOUND]:"File not found.",[e.CLOSED]:"File is closed.",[e.ALREADY_OPENED]:"File already opened.",[e.NOT_ASSIGNED]:"File is not yet opened.",[e.READONLY]:"File is in read-only mode.",[e.WRITEONLY]:"File is in write-only mode.",[e.WRITE_ERROR]:"Error when writing file.",[e.FILE_ENDED]:"File is at end."},a=(e,r)=>{self.postMessage({command:e,data:r})},l=(e,r)=>{a("finish",{error:e,exitMessage:r})},f={iobuffer:null,sendCommand:a,memory:null,instance:null},d=function(r){let a="",l="",f={};const d=new TextDecoder;let m=-1;const c=()=>{m<0?(Atomics.store(r.iobuffer,0,0),r.sendCommand("read",{}),Atomics.wait(r.iobuffer,0,0)):u("read",{fileId:m});const e=r.iobuffer[1];if(0===e)return;if(e<0)throw new t;const n=new Uint8Array(e);for(let t=0;t<e;t++)n[t]=r.iobuffer[t+2];a+=d.decode(n)},u=(t,o)=>{Atomics.store(r.iobuffer,0,0),r.sendCommand(t,o),Atomics.wait(r.iobuffer,0,0);const i=Atomics.load(r.iobuffer,0);if(i!==e.OK)throw new n(s[i])},y=e=>{const t=e+1,n=t+r.memory[e];return d.decode(r.memory.slice(t,n))},w=(e,t,n)=>{const o=Math.min(n.length,t);r.memory[e]=o;for(let t=0;t<o;t++)r.memory[e+t+1]=n.charCodeAt(t)},E=(e,r)=>{let t=r-e.length;return t<1?e:" ".repeat(t)+e},$=e=>{const t={value:e};m<0?r.sendCommand("write",t):(t.fileId=m,u("write",t))},A=(e,t)=>(Atomics.store(r.iobuffer,0,0),r.sendCommand(e,t),Atomics.wait(r.iobuffer,0,0),r.iobuffer[1]),h=e=>{u("readbyte",{fileId:m,size:e})};return{rtl:{$updatemem:e=>{if(e<0)throw new n("Out of memory");const t=r.instance.exports;r.memory=new Uint8Array(t.mem.buffer)},$putint:(e,r,t)=>{let n;switch(r){case 1:n=String.fromCharCode(e);break;case 2:n=0===e?"FALSE":"TRUE";break;default:n=e.toString()}$(E(n,t))},$putreal:(e,r,t)=>{let n=t<0?e.toExponential():e.toFixed(t);$(E(n,r))},$putln:()=>{$("\n")},$putstr:(e,r)=>{$(E(y(e),r))},$readint:()=>{let e;for(;;){if(a=o(a),[e,a]=i(a),e){let r=parseInt(e,10);if(isNaN(r))throw new n("Invalid integer format");return r}c()}},$readchar:()=>{a.length<1&&c();let e=a.charCodeAt(0);return a=a.slice(1),e},$readreal:()=>{let e;for(;;){if(a=o(a),[e,a]=i(a),e){let r=parseFloat(e);if(isNaN(r))throw new n("Invalid floating-point number format");return r}c()}},$readstr:(e,t)=>{a.length<1&&c();const n=a.indexOf("\n");let o="";n>=0?(o=a.slice(0,n),a=a.slice(n)):(o=a,a=""),o.length>t&&(o=o.slice(0,t)),r.memory[e]=o.length;for(let t=0;t<o.length;t++)r.memory[e+1+t]=o.charCodeAt(t)},$readln:()=>{a.length<1&&c();const e=a.indexOf("\n");e>=0&&(a=a.slice(e+1))},$fset:e=>{m=e,l=a,a=f[e]},$funset:()=>{f[m]=a,a=l,m=-1},$fputint:(e,r)=>{let t;if(0===r){let r=new ArrayBuffer(4);new Int32Array(r)[0]=e,t=new Uint8Array(r)}else t=new Uint8Array(1),t[0]=255&e;$(t)},$fputreal:e=>{let r=new ArrayBuffer(8);new Float64Array(r)[0]=e,$(new Uint8Array(r))},$fputmem:(e,t)=>{let n=new Uint8Array(t);for(let o=0;o<t;o++)n[o]=r.memory[e+o];$(n)},$freadint:e=>{if(h(0===e?4:1),0!==e)return r.iobuffer[2];let t=new ArrayBuffer(4),n=new Int32Array(t),o=new Uint8Array(t);for(let e=0;e<4;e++)o[e]=r.iobuffer[e+2];return n[0]},$freadreal:()=>{h(8);let e=new ArrayBuffer(8),t=new Float64Array(e),n=new Uint8Array(e);for(let e=0;e<8;e++)n[e]=r.iobuffer[e+2];return t[0]},$freadmem:(e,t)=>{let n=e,o=t;for(;o>0;){let e=Math.min(o,r.iobuffer.length-2);h(e);for(let t=0;t<e;t++)r.memory[n+t]=r.iobuffer[t+2];o-=e,n+=e}},$assign:(e,t)=>{const n=y(t);r.sendCommand("assignFile",{fileId:e,filename:n})},$reset:e=>{f[e]="",u("resetFile",{fileId:e})},$rewrite:e=>{u("rewriteFile",{fileId:e})},$close:e=>{u("closeFile",{fileId:e})},$eof:e=>(u("eofFile",{fileId:e}),0!==r.iobuffer[2]),$pos:(e,r)=>{const t=y(e);return y(r).indexOf(t)+1},$upcase:(e,r,t)=>{const n=y(t);return w(e,r-1,n.toUpperCase()),e},$copy:(e,r,t,n,o)=>{let i=y(t);return(n-=1)<0&&(n=0),i=i.substring(n,n+o),w(e,r-1,i),e},$delete:(e,r,t)=>{let n=y(e),o=n.length;(r-=1)<0&&(r=0),n=n.substring(0,r)+n.substring(r+t),w(e,o,n)},$randomize:()=>{},$random:()=>Math.random(),$randomint:e=>Math.floor(Math.random()*e)},crt:{$clrscr:()=>{r.sendCommand("clrscr")},$cursoron:()=>{},$cursoroff:()=>{},$delay:e=>{A("delay",{value:e})},$gotoxy:(e,t)=>{r.sendCommand("gotoxy",{x:e,y:t})},$wherex:()=>A("wherex"),$wherey:()=>A("wherey"),$readkey:()=>A("readkey")},debug:{$int:(e,r)=>{console.log("debug int",e,r)},$float:(e,r)=>{console.log("debug float",e,r)},$str:(e,r)=>{const t=y(r);console.log("debug str",e,t.length,t)}}}}(f);self.addEventListener("message",(e=>{f.iobuffer||function(e,r){f.iobuffer=e;const o=new WebAssembly.Module(r),i=new WebAssembly.Instance(o,d);f.instance=i,f.memory=new Uint8Array(i.exports.mem.buffer);try{i.exports.main(),l(!1,"\nProgram finished.\n")}catch(e){e instanceof t?l(!1,"\nProgram interrupted.\n"):e instanceof n?l(!0,`\n${e.message}\n`):(console.error(e),l(!0,"\nRuntime error.\n"))}}(e.data.iobuffer,e.data.binary)}));